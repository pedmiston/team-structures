---
title: |
  The effects of cultural inheritance  
  on problem solving ability
author:
  \textbf{Pierce Edmiston}$^1$, Maxime Derex$^2$, Gary Lupyan$^1$
bibliography: references.bib
csl: apa.csl
output:
  beamer_presentation:
    theme: metropolis
    keep_tex: yes
    template: template/slides.tmpl
---
```{r setup, include=FALSE}
library(knitr)
library(tidyverse)
library(crotchet)
opts_chunk$set(echo=FALSE, message=FALSE, warning=FALSE, cache=TRUE)
read_chunk("team-structures.R")
```
```{r team-structures, include=FALSE}
```
```{r config, include=FALSE, cache=FALSE}
t_$base_theme$text$size <- 20
t_$annotation_size <- 5
theme_set(t_$base_theme)
```

# Cumulative cultural evolution

Populations solve increasingly complex problems over generations  
that individuals struggle to solve on their own.

```{r computer, fig.cap="The Difference Engine and the Apple Watch S3."}
gridExtra::grid.arrange(
  crotchet::read_image("img/difference-engine.jpg", width = 0.9),
  crotchet::read_image("img/apple-watch.jpg", width = 0.9),
  nrow = 1
)
```


Here are two computers.

The one on the left is a portion of the Difference Engine, a 15 ton
machine designed by Charles Babbage in the 1820s, but famously never actually
completed, or at least not in his lifetime. The difference engine was designed
to compute arbitrary functions, so it was a very early computer.

On the right, we have the inside of an Apple Watch S3 --- a solid state computer
you can wear on your wrist, with no moving parts. The Apple Watch is made by a
company with over 120,000 employees, worth over one trillion dollars, that makes
about 4 million of these every quarter.

By every measure I can think of, the Apple Watch is a much better computer than
the Difference Engine, and this is the kind of cumulative cultural evolution I
think we can all agree on.

Human populations are somehow able to solve increasingly complex problems over
generations that individuals struggle to solve on their own.

The question I'm interested in is WHY.
Why are cultures better at solving problems than individuals?


# Why are cultures better at solving problems than individuals?

Inheritance
:   Problem solving extends beyond a single lifetime.

Group size
:   Individuals can coordinate labor in large groups.

\vspace{2em}

**Does culture have an impact on problem solving ability?**


There are two answers to this question I want to talk about today. The first is
the idea of inheritance: because we can pass our knowledge from one generation
to the next, problem solving can extend far longer than any individual
lifetime.

The second answer is related to group size. This is the idea that individuals
can coordinate their labor in groups to accomplish something that they couldn't
do by themselves.

To me, as a psychologist, the most interesting question is whether
culture in either case actually has an impact on problem solving ability.
Does problem solving just add up as you add more generations or more
people to the group, or are there interactions, places where the group
actually performs better than the sum of its parts?

I'm going to argue that we know a fair amount about the effects of working in a
group on problem solving ability, but we actually don't know very much about the
effects on inheritance on problem solving.


# When does working in a group improve problem solving?

**Not very often!**

Group benefits in search tasks[^search]:

- Wider search
- Avoid premature convergence
- Better exploitation

[^search]: e.g., @Hong:2004gt; @Mason:2012jx; @Derex:2016hj


When does working together in a group improve the performance
of its members?

From the perspective of cognitive psychology, the answer to this question is
"not very often". For most problem solving tasks that individuals can do alone,
making them do it in a group doesn't usually make them do it any better.

But there is one class of problems where groups tend to do better than
individuals, and that is in search tasks. These are problems where people
need to search a space of possible solutions looking for the best ones. In
these cases, working in a group tends to help by widening the search, 
preventing premature convergence on locally optimal solutions, and
making it easier to exploit optimal solutions.

So we know that working in a group doesn't always improve problem
solving, but there are decently well-defined situations in which
it does seem to help.


# When is it more effective to inherit from a previous generation?

**Hard to answer!**

- Copying isn't always advantageous, but when it is, it's additive.
- Transmission chain experiments have studied _capacity_, not _effectiveness_.


Now let me ask a parallel question about the effects of inheritance on
problem solving.

When is it more effective to inherit from a previous generation as opposed
to solving the same problem individually?

I think this question is much harder to answer.

From modeling work, we know that copying isn't always advantageous, as it
depends on factors like the stability of the environment and the number of
parents.

But even when the environment is stable and you have many parents to choose from,
inheritance is mostly effective because individual lives are limited, not because
it confers any downstream benefits to future generations.

The experimental work that has addressed this question, using transmission
chain designs, has focused more on capacity to inherit from an ancestor
rather than the effectiveness of inheritance as a problem solving strategy.

So how do we answer this question?


# Measuring the effects of cultural inheritance on problem solving

```{r team-structures-1, out.height="80%", fig.align="center"}
crotchet::draw_graphviz("team-structures", package = "totems")
```


Here is my claim.

If we want to understand the effects of cultural inheritance on problem
solving, we need to compare the effectiveness of this strategy, which I refer
to as "diachronic problem solving", to alternative ways of solving the same set
of problems.

The two alternative strategies I'm most interested in are isolated
individuals working alone, and synchronic problem solving, which is a more
traditional group work structure where people are working in parallel.

The experiments I'm going to tell you about in a minute all use some
variant of this design.


# Types of time[^helena]

```{r types-of-time, fig.width=5, fig.height=2, fig.cap="Team structures controlling for labor time."}
gridExtra::grid.arrange(
  crotchet::read_graphviz("team-structures", package = "totems"),
  gg_time,
  gg_person,
  nrow = 1,
  widths = c(0.25, 0.375, 0.375)
)
```

[^helena]: @Miton:2018ef


What's important about this is that I'm controlling for labor hours
in order to make my comparisons, and that makes these experiments different
than ones that control for calendar hours.

Each strategy is allotted the same number of labor hours.
In the middle I'm showing you that the synchronic strategy spends the same
number of labor hours in fewer calendar hours than the other strategies.

The plot on the right is showing that an isolated strategy has the
most time for individual learning.

I'm not the only person to argue that controlling for labor hours is
important. Helena Miton has a great paper that argues for this,
and there have been debates in the group problem solving literature
about it as well.


# All team structure conditions

```{r team-structures-all, out.height="80%", fig.align="center"}
crotchet::draw_graphviz("team-structures-all", package = "totems")
```


Here I'm showing you all the conditions we ran, and the experiments
I'm going to tell you about are going to focus on particular
comparisons out of this set.

But before I talk about the results, I first better tell you
what problem solving task we had people complete.


# The Totem Game [@Derex:2015cbb]

```{r gameplay, out.height="90%"}
draw_image("gameplay", package = "totems")
```


We had participants play the Totem Game, which was designed by
my collaborator Max Derex.

In the Totem Game, participants combine resources to make tools,
and combine those tools to make other tools, and so on and so on
all for the sake of building a sacred totem to appease the gods.

This game was originally used to test a number of hypotheses
related to when groups outperform individuals on the same task,
and I encourage you to check out the original paper if you want
to know more.

In this case, we extended the game to allow for diachronic
inheritance. For these participants, rather than starting off
with nothing, they began the experiment with access to the recipes
that had been discovered by one participant in the previous generation.


# Recipes

```{r recipes, out.height="80%"}
crotchet::draw_image("recipes.gv", package = "totems")
```




# Solution landscape

```{r landscape, out.height="80%"}
crotchet::draw_image("landscape-sample.gv", package = "totems")
```




# Overview of experiments

1. Simple diachronic inheritance
2. Diachronic versus isolated
3. Scalability of diachronic and synchronic

# Simple diachronic inheritance

```{r team-structures-50min, out.height="80%", fig.align="center"}
crotchet::draw_graphviz("team-structures-50min", package = "totems")
```

# Simple diachronic inheritance

```{r innovations-50min}
grid.arrange(
  innovation_rate_50min_plot,
  num_innovations_50min_plot,
  nrow = 1,
  widths = c(0.55, 0.45)
)
```


Here are the results.

We replicated the original finding that working in a synchronic group is more
effective than working individually even when you control for labor hours,
but what I was really interested in was how the diachronic group would
pattern out. And we can see that the diachronic group falls in the middle ---
not signifantly more effective than an isolated strategy, but not significantly
less effective than a synchronic strategy.

So the main takeaway here is that the simplest form of diachronic inheritance
is comparable to these other strategies, and the main question then is what
happens when we add more generations to this chain.


# Diachronic versus individual inheritance

```{r team-structures-selfother}
crotchet::draw_graphviz("team-structures-selfother", package = "totems")
```


For the next experiment we compared a diachronic strategy
over four generations to an isolated strategy where the same
person came back for four sessions, spaced at least one
day apart.


# Diachronic versus individual inheritance

```{r innovations-by-generation-selfother}
innovations_by_generation_plot
```


If we just look at the overall number of innovations, we see the cost
of diachronic inheritance, as the people in the isolated strategy
discovered more tools after four sessions than the people in the
diachronic strategy.

But it gets a little more interesting when we dig into why the isolated
strategy is able to pull ahead.


# Learning times

```{r learning-times}
learning_times_plot
```


Here I'm showing you the amount of time out of the 25 minute session
that each person spent recreating the items they had inherited as opposed
to attempting to discover new items.


# First discovery

```{r first-discovery}
first_discovery_by_generation_plot
```

# Scalability of diachronic and synchronic strategies

Do the diachronic and synchronic strategies diverge when more people are added to the group?

# Innovations by team size

```{r scalability}
max_innovations_by_teamsize_plot
```

# Simulations of team size

```{r scalability-simulations}
bots_team_size_plot + scale_x_discrete(labels = c("small", "large"))
```

# Summary

Can cultural inheritance improve the problem solving abilities of future generations?

- Answering this question requires proper control conditions.
- A diachronic strategy remediates the cost of fixation.
- A diachronic strategy is more scalable than a sychronic strategy.

# Open science

`github.com/pedmiston/team-structures`  

```{r r-package, echo=TRUE, eval=FALSE}
remotes::instalL_github("pedmiston/totems-data")  # installs "totems" package
data(package = "totems")                          # lists all datasets in package
```

# The effects of cultural inheritance on problem solving ability

**Pierce Edmiston**, Max Derex, Gary Lupyan  
pedmiston@wisc.edu  

# References {.allowframebreaks}

\setlength{\parindent}{-0.2in}
\setlength{\leftskip}{0.25in}
\noindent
\footnotesize
